---
phase: 25-foundation-blockers
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/cli/src/hooks/useWebSocket.ts
  - apps/desktop/src/hooks/useWebSocket.ts
autonomous: true
requirements:
  - FOUND-03

must_haves:
  truths:
    - "CLI WebSocket client automatically reconnects with exponential backoff (1s->2s->4s->8s->max 30s) after gateway disconnects"
    - "Desktop WebSocket client automatically reconnects with exponential backoff (1s->2s->4s->8s->max 30s) after gateway disconnects"
    - "Both clients have unlimited retries (no max retry cap)"
    - "Both clients re-send sessionId on reconnection to resume the session"
    - "Reconnect attempt counter resets to 0 on successful connection"
  artifacts:
    - path: "packages/cli/src/hooks/useWebSocket.ts"
      provides: "CLI WebSocket hook with exponential backoff reconnect"
      contains: "getReconnectDelay"
    - path: "apps/desktop/src/hooks/useWebSocket.ts"
      provides: "Desktop WebSocket hook with exponential backoff reconnect"
      contains: "getReconnectDelay"
  key_links:
    - from: "packages/cli/src/hooks/useWebSocket.ts"
      to: "ws close handler"
      via: "setTimeout with exponential delay"
      pattern: "getReconnectDelay.*attempt"
    - from: "apps/desktop/src/hooks/useWebSocket.ts"
      to: "Tauri WS Close handler"
      via: "setTimeout with exponential delay"
      pattern: "getReconnectDelay.*attempt"
---

<objective>
Add exponential backoff auto-reconnect to both CLI and desktop WebSocket hooks so clients automatically recover after gateway restarts.

Purpose: Without auto-reconnect, users must manually restart the CLI or desktop app when the gateway restarts. Exponential backoff prevents thundering herd while ensuring eventual reconnection.
Output: Both useWebSocket hooks reconnect with 1s->2s->4s->8s->max 30s backoff, unlimited retries, and session resumption.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-foundation-blockers/25-RESEARCH.md
@packages/cli/src/hooks/useWebSocket.ts
@apps/desktop/src/hooks/useWebSocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add exponential backoff reconnect to CLI useWebSocket</name>
  <files>packages/cli/src/hooks/useWebSocket.ts</files>
  <action>
    The current CLI hook has ZERO reconnect logic — it creates a single WebSocket and never retries.

    Add a `getReconnectDelay` utility function at the top of the file (or inline):
    ```typescript
    const BASE_DELAY_MS = 1000;
    const MAX_DELAY_MS = 30_000;
    const JITTER_FACTOR = 0.3;

    function getReconnectDelay(attempt: number): number {
      const exponential = Math.min(BASE_DELAY_MS * 2 ** attempt, MAX_DELAY_MS);
      const jitter = exponential * JITTER_FACTOR * Math.random();
      return exponential + jitter;
    }
    ```

    Modify the hook to add reconnect infrastructure:
    1. Add `attemptRef = useRef(0)` for tracking reconnect attempts.
    2. Add `reconnectTimerRef = useRef<ReturnType<typeof setTimeout>>()` for the reconnect timer.
    3. Add `sessionIdRef = useRef<string | null>(null)` to track the current session ID for resumption.
    4. Add `mountedRef = useRef(true)` to prevent reconnect after unmount.

    Extract the WebSocket creation into a `connect` function (wrapped in useCallback):
    - On `ws.on("open")`: set connected=true, reset `attemptRef.current = 0`.
    - On `ws.on("message")`: parse the message. If the parsed message has a `sessionId` field (string), store it in `sessionIdRef.current`. Call `onMessageRef.current(msg)`.
    - On `ws.on("close")`: set connected=false, null out wsRef. If `mountedRef.current` is true, calculate delay via `getReconnectDelay(attemptRef.current)`, increment attemptRef, schedule `reconnectTimerRef.current = setTimeout(connect, delay)`.
    - On `ws.on("error")`: call `onErrorRef.current?.(err)`, then `ws.close()` (which triggers the close handler for reconnect).

    Update the useEffect cleanup:
    - Set `mountedRef.current = false`.
    - Clear `reconnectTimerRef.current` if set.
    - Close the WebSocket.

    Add `sessionId` to the return type so callers can access it:
    - Add `sessionId: string | null` to `UseWebSocketReturn`.
    - Return `sessionIdRef.current` (or expose a getter).

    Keep the existing `UseWebSocketOptions` and `UseWebSocketReturn` interfaces, extending as needed. Do NOT change the external API beyond adding `sessionId` to the return.
  </action>
  <verify>
    Run `cd /Users/hitekmedia/Documents/GitHub/tek && pnpm turbo build --filter=@tek/cli` — CLI builds without TypeScript errors. Verify the file contains `getReconnectDelay` and `attemptRef`.
  </verify>
  <done>
    CLI useWebSocket hook reconnects automatically on disconnect with exponential backoff (1s->2s->4s->8s->max 30s), no retry limit, resets attempt counter on successful open, and tracks sessionId for resumption.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update desktop useWebSocket to exponential backoff</name>
  <files>apps/desktop/src/hooks/useWebSocket.ts</files>
  <action>
    The desktop hook already has reconnect logic but uses fixed 3s delay with max 5 retries. Three changes needed:

    1. **Add the same `getReconnectDelay` function** at the top of the file:
       ```typescript
       const BASE_DELAY_MS = 1000;
       const MAX_DELAY_MS = 30_000;
       const JITTER_FACTOR = 0.3;

       function getReconnectDelay(attempt: number): number {
         const exponential = Math.min(BASE_DELAY_MS * 2 ** attempt, MAX_DELAY_MS);
         const jitter = exponential * JITTER_FACTOR * Math.random();
         return exponential + jitter;
       }
       ```

    2. **Remove the retry cap:** Delete `const MAX_RETRIES = 5;` and `const RECONNECT_DELAY_MS = 3000;`. In both reconnect locations (inside the `Close` message handler and in the `catch` block of `connect`):
       - Remove the `retriesRef.current < MAX_RETRIES` condition — always reconnect while mounted and URL exists.
       - Replace `RECONNECT_DELAY_MS` with `getReconnectDelay(retriesRef.current)`.
       - Increment `retriesRef.current` BEFORE scheduling the timeout (so the delay reflects the current attempt).

    3. **Add sessionId tracking:** Add `sessionIdRef = useRef<string | null>(null)`. In the message listener, when a parsed message has a `sessionId` string field, store it: `if (parsed && typeof parsed === 'object' && 'sessionId' in parsed) sessionIdRef.current = (parsed as {sessionId: string}).sessionId;`. Add `sessionId: string | null` to `UseWebSocketReturn` and return `sessionIdRef.current`.

    Keep the existing `cleanup`, `connect`, `send`, `addMessageHandler`, `removeMessageHandler` structure. The changes are minimal — replace constants and remove the cap condition.
  </action>
  <verify>
    Run `cd /Users/hitekmedia/Documents/GitHub/tek && pnpm turbo build --filter=@tek/desktop` — desktop builds without TypeScript errors. Verify the file no longer contains `MAX_RETRIES` or `RECONNECT_DELAY_MS` constants.
  </verify>
  <done>
    Desktop useWebSocket hook uses exponential backoff (1s->2s->4s->8s->max 30s), has no retry limit, resets attempt counter on successful connect, and tracks sessionId for resumption.
  </done>
</task>

</tasks>

<verification>
1. `pnpm turbo build --filter=@tek/cli` succeeds
2. `pnpm turbo build --filter=@tek/desktop` succeeds
3. `grep "MAX_RETRIES" apps/desktop/src/hooks/useWebSocket.ts` returns nothing (removed)
4. `grep "getReconnectDelay" packages/cli/src/hooks/useWebSocket.ts` returns match
5. `grep "getReconnectDelay" apps/desktop/src/hooks/useWebSocket.ts` returns match
6. `grep "sessionIdRef" packages/cli/src/hooks/useWebSocket.ts` returns match
7. `grep "sessionIdRef" apps/desktop/src/hooks/useWebSocket.ts` returns match
</verification>

<success_criteria>
- CLI WebSocket hook reconnects with exponential backoff after disconnect
- Desktop WebSocket hook reconnects with exponential backoff after disconnect
- Both hooks have unlimited retries (no MAX_RETRIES cap)
- Both hooks track and expose sessionId for session resumption
- Backoff sequence: ~1s, ~2s, ~4s, ~8s, ~16s, ~30s (capped) with jitter
- Attempt counter resets to 0 on successful connection
</success_criteria>

<output>
After completion, create `.planning/phases/25-foundation-blockers/25-03-SUMMARY.md`
</output>
