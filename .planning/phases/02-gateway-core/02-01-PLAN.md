---
phase: 02-gateway-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/sessions.ts
  - packages/db/src/schema/messages.ts
  - packages/db/src/schema/usage.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/connection.ts
  - packages/gateway/package.json
  - packages/gateway/src/ws/protocol.ts
  - packages/gateway/src/ws/connection.ts
  - packages/gateway/src/ws/server.ts
  - packages/gateway/src/ws/index.ts
  - packages/gateway/src/session/types.ts
  - packages/gateway/src/session/store.ts
  - packages/gateway/src/session/manager.ts
  - packages/gateway/src/session/index.ts
  - packages/gateway/src/index.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket endpoint at /gateway accepts connections on the same Fastify instance as the key-server"
    - "JSON messages are validated with Zod discriminated unions on inbound and outbound paths"
    - "Sessions are created with transparent keys in format agent:{agentId}:{nanoid} and persisted to SQLite"
    - "Session, message, and usage_records tables exist in SQLite with correct schema"
  artifacts:
    - path: "packages/db/src/schema/sessions.ts"
      provides: "Sessions Drizzle table schema"
      contains: "sqliteTable"
    - path: "packages/db/src/schema/messages.ts"
      provides: "Messages Drizzle table schema"
      contains: "sqliteTable"
    - path: "packages/db/src/schema/usage.ts"
      provides: "Usage records Drizzle table schema"
      contains: "sqliteTable"
    - path: "packages/gateway/src/ws/protocol.ts"
      provides: "Client and server message Zod schemas"
      exports: ["ClientMessageSchema", "ServerMessageSchema"]
    - path: "packages/gateway/src/ws/server.ts"
      provides: "Fastify WS registration on /gateway route"
      contains: "websocket"
    - path: "packages/gateway/src/session/manager.ts"
      provides: "Session create/get/list with SQLite persistence"
      exports: ["SessionManager"]
  key_links:
    - from: "packages/gateway/src/ws/server.ts"
      to: "packages/gateway/src/ws/protocol.ts"
      via: "Validates inbound messages with ClientMessageSchema.safeParse"
      pattern: "ClientMessageSchema\\.safeParse"
    - from: "packages/gateway/src/session/store.ts"
      to: "packages/db/src/schema/sessions.ts"
      via: "Drizzle insert/select on sessions table"
      pattern: "sessions"
    - from: "packages/gateway/src/ws/server.ts"
      to: "@fastify/websocket"
      via: "Plugin registration with route handler"
      pattern: "websocket.*true"
---

<objective>
Set up the WebSocket gateway infrastructure: DB schemas for session/message/usage persistence, typed JSON protocol with Zod validation, WebSocket server endpoint on the existing Fastify instance, and session management with transparent keys and SQLite storage.

Purpose: Establish the communication and persistence foundation that Plan 02-02 will wire to LLM streaming and context inspection.
Output: Working WebSocket endpoint that accepts connections, validates messages, creates/restores sessions, and persists session state.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gateway-core/02-RESEARCH.md
@.planning/phases/01-foundation-security/01-03-SUMMARY.md
@packages/db/src/schema/audit-log.ts
@packages/db/src/connection.ts
@packages/gateway/src/key-server/server.ts
@packages/gateway/src/index.ts
@packages/gateway/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB schemas and package dependencies</name>
  <files>
    packages/db/src/schema/sessions.ts
    packages/db/src/schema/messages.ts
    packages/db/src/schema/usage.ts
    packages/db/src/schema/index.ts
    packages/db/src/connection.ts
    packages/gateway/package.json
  </files>
  <action>
**1. Install Phase 2 dependencies in @agentspace/gateway:**
```bash
pnpm --filter @agentspace/gateway add @fastify/websocket ai @ai-sdk/anthropic tokenx nanoid
pnpm --filter @agentspace/gateway add -D @types/ws
```

**2. Create DB schemas matching the research patterns:**

`packages/db/src/schema/sessions.ts`:
```typescript
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';

export const sessions = sqliteTable('sessions', {
  id: text('id').primaryKey(),              // nanoid
  sessionKey: text('session_key').notNull().unique(),
  agentId: text('agent_id').notNull().default('default'),
  model: text('model').notNull(),
  createdAt: text('created_at').notNull(),   // ISO 8601
  lastActiveAt: text('last_active_at').notNull(),
});
```

`packages/db/src/schema/messages.ts`:
```typescript
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { sessions } from './sessions.js';

export const messages = sqliteTable('messages', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  sessionId: text('session_id').notNull().references(() => sessions.id),
  role: text('role').notNull(),              // 'user' | 'assistant' | 'system'
  content: text('content').notNull(),
  createdAt: text('created_at').notNull(),
  tokenCount: integer('token_count'),        // Actual token count from usage
});
```

`packages/db/src/schema/usage.ts`:
```typescript
import { sqliteTable, text, integer, real } from 'drizzle-orm/sqlite-core';
import { sessions } from './sessions.js';

export const usageRecords = sqliteTable('usage_records', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  sessionId: text('session_id').notNull().references(() => sessions.id),
  model: text('model').notNull(),
  inputTokens: integer('input_tokens').notNull(),
  outputTokens: integer('output_tokens').notNull(),
  totalTokens: integer('total_tokens').notNull(),
  cost: real('cost').notNull(),              // USD
  timestamp: text('timestamp').notNull(),
});
```

**3. Update `packages/db/src/schema/index.ts`** to re-export all three new schemas alongside existing auditLog.

**4. Update `packages/db/src/connection.ts`** `getDb()` function: add CREATE TABLE IF NOT EXISTS statements for `sessions`, `messages`, and `usage_records` tables, following the same pattern as the existing `audit_log` auto-create. The Drizzle schema import (`* as schema`) already picks up new exports from the schema index. Make sure the `messages` and `usage_records` foreign keys reference `sessions(id)`.
  </action>
  <verify>
Run `pnpm --filter @agentspace/gateway build` and `pnpm --filter @agentspace/db build` -- both must succeed without type errors. Verify all three new schema files exist and export the expected table constants. Verify `connection.ts` has CREATE TABLE IF NOT EXISTS for sessions, messages, and usage_records.
  </verify>
  <done>Three new Drizzle table schemas (sessions, messages, usage_records) exist and compile. Gateway package.json has @fastify/websocket, ai, @ai-sdk/anthropic, tokenx, nanoid as dependencies and @types/ws as devDependency. getDb() auto-creates all four tables on first run.</done>
</task>

<task type="auto">
  <name>Task 2: WebSocket protocol, server, session manager, and connection handling</name>
  <files>
    packages/gateway/src/ws/protocol.ts
    packages/gateway/src/ws/connection.ts
    packages/gateway/src/ws/server.ts
    packages/gateway/src/ws/index.ts
    packages/gateway/src/session/types.ts
    packages/gateway/src/session/store.ts
    packages/gateway/src/session/manager.ts
    packages/gateway/src/session/index.ts
    packages/gateway/src/index.ts
  </files>
  <action>
**1. Create `packages/gateway/src/ws/protocol.ts`** -- Zod schemas for all client and server message types:

Client messages (discriminated union on `type`):
- `chat.send`: `{ type, id, sessionId?, content, model? }`
- `context.inspect`: `{ type, id, sessionId }`
- `usage.query`: `{ type, id, sessionId? }`
- `session.list`: `{ type, id }`

Server messages (discriminated union on `type`):
- `chat.stream.start`: `{ type, requestId, sessionId, model }`
- `chat.stream.delta`: `{ type, requestId, delta }`
- `chat.stream.end`: `{ type, requestId, usage: { inputTokens, outputTokens, totalTokens }, cost: { inputCost, outputCost, totalCost } }`
- `context.inspection`: `{ type, requestId, sections: Array<{ name, content, byteCount, tokenEstimate, costEstimate }>, totals: { byteCount, tokenEstimate, costEstimate } }`
- `usage.report`: `{ type, requestId, perModel: Record<string, { inputTokens, outputTokens, totalTokens, totalCost, requestCount }>, grandTotal: { totalCost, totalTokens, requestCount } }`
- `error`: `{ type, requestId?, code, message }`
- `session.created`: `{ type, sessionId, sessionKey }`
- `session.list`: `{ type, requestId, sessions: Array<{ sessionId, sessionKey, model, createdAt, messageCount }> }`

Export TypeScript types inferred from each schema: `type ClientMessage = z.infer<typeof ClientMessageSchema>`, etc. Also export individual literal type schemas for handler use.

**2. Create `packages/gateway/src/session/types.ts`** -- Session interface:
```typescript
export interface Session {
  id: string;
  sessionKey: string;  // 'agent:{agentId}:{id}'
  agentId: string;
  model: string;
  createdAt: string;
  lastActiveAt: string;
}
```

Also export `DEFAULT_MODEL = 'claude-sonnet-4.5'` constant.

**3. Create `packages/gateway/src/session/store.ts`** -- SQLite persistence layer:
- `saveSession(session: Session): void` -- insert into sessions table using Drizzle
- `getSession(id: string): Session | undefined` -- select by id
- `updateLastActive(id: string): void` -- update lastActiveAt to current ISO timestamp
- `listSessions(): SessionSummary[]` -- select all sessions with message count (join with messages table, count)
- `saveMessage(sessionId: string, role: string, content: string, tokenCount?: number): void` -- insert into messages table
- `getMessages(sessionId: string, limit?: number): MessageRow[]` -- select messages for session ordered by id desc, limit (default 50), return in chronological order

All functions are synchronous (matching better-sqlite3 pattern from Phase 1). Use `getDb()` from @agentspace/db.

**4. Create `packages/gateway/src/session/manager.ts`** -- SessionManager class:
- `create(agentId?: string, model?: string): Session` -- generate nanoid, build sessionKey as `agent:${agentId}:${id}`, persist via store, return Session
- `get(sessionId: string): Session | undefined` -- load from store, update lastActiveAt
- `addMessage(sessionId: string, role: string, content: string, tokenCount?: number): void` -- delegate to store
- `getMessages(sessionId: string, limit?: number): MessageRow[]` -- delegate to store
- `list(): SessionSummary[]` -- delegate to store

Use nanoid for ID generation. Export a singleton `sessionManager` instance.

**5. Create `packages/gateway/src/session/index.ts`** -- barrel exports for sessionManager, types, DEFAULT_MODEL.

**6. Create `packages/gateway/src/ws/connection.ts`** -- Connection tracking:
- `ConnectionState` type: `{ sessionId: string | null, streaming: boolean }`
- `ConnectionMap` using a WeakMap<WebSocket, ConnectionState> to track per-connection state
- `markStreaming(ws, requestId)` / `clearStreaming(ws)` / `isStreaming(ws)` helpers to guard against concurrent streams per connection (see Pitfall 5 in research)
- Export functions for connection lifecycle management

**7. Create `packages/gateway/src/ws/server.ts`** -- `registerGatewayWebSocket(fastify: FastifyInstance)`:
- Register @fastify/websocket plugin with `{ options: { maxPayload: 1048576 } }` (1MB max)
- Register a scoped plugin with a GET `/gateway` route with `{ websocket: true }`
- **CRITICAL:** Attach socket.on('message'), socket.on('close'), socket.on('error') handlers SYNCHRONOUSLY in the route handler (see Pitfall 2 in research)
- In the message handler: parse JSON, validate with `ClientMessageSchema.safeParse()`, dispatch by `msg.type`
- For now, implement only `session.list` handler (calls sessionManager.list()) and stub the other handlers (chat.send, context.inspect, usage.query) to return `{ type: 'error', code: 'NOT_IMPLEMENTED' }`. Plan 02-02 will implement those.
- On new `chat.send` with no sessionId: create session via sessionManager, send `session.created` message back
- On `chat.send` with sessionId: validate session exists, reject with error if not found
- On close: log disconnection, clean up connection state
- Add `preValidation` hook on the WS route to check `req.ip === '127.0.0.1'` for localhost-only auth (per research recommendation)

**8. Create `packages/gateway/src/ws/index.ts`** -- barrel exports for registerGatewayWebSocket, protocol types.

**9. Update `packages/gateway/src/index.ts`**:
- Export `registerGatewayWebSocket` from `./ws/index.js`
- Export session-related types and sessionManager from `./session/index.js`
- Update the direct-run block to also register the WS plugin on the same Fastify instance as the key-server. Modify the createKeyServer factory or call registerGatewayWebSocket on the returned server instance BEFORE it starts listening. This means the direct-run code should: (1) create Fastify instance, (2) register key-server routes, (3) register WS gateway, (4) listen. Refactor createKeyServer to accept a Fastify instance or expose the registration separately so the WS plugin can coexist on the same server.
  </action>
  <verify>
Run `pnpm --filter @agentspace/gateway build` -- must succeed. Verify that the gateway starts with `pnpm --filter @agentspace/gateway exec tsx src/index.ts` and both `/health` and WebSocket at `/gateway` are accessible. Test with: `npx wscat -c ws://127.0.0.1:3271/gateway` -- should connect. Send `{"type":"session.list","id":"test-1"}` -- should return a session.list response with empty sessions array.
  </verify>
  <done>WebSocket endpoint at /gateway coexists with key-server on same Fastify instance. Messages are validated with Zod. Session manager creates/retrieves sessions with transparent keys (agent:default:{nanoid}) persisted to SQLite. Connection state tracks streaming status per connection. session.list handler works, other handlers return NOT_IMPLEMENTED stubs.</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds across all packages (db, gateway)
2. Gateway starts on port 3271 with both /health and /gateway endpoints
3. WebSocket connects to ws://127.0.0.1:3271/gateway
4. Sending `{"type":"session.list","id":"t1"}` returns valid JSON with `type: "session.list"`
5. Sending `{"type":"chat.send","id":"t2","content":"hello"}` creates a session and returns `session.created` + `NOT_IMPLEMENTED` error
6. Sending invalid JSON returns an `error` message with code `INVALID_MESSAGE`
7. SQLite database has sessions, messages, usage_records tables (check with `sqlite3 ~/.config/agentspace/agentspace.db ".tables"`)
</verification>

<success_criteria>
- WebSocket server accepts connections at /gateway on same port as key-server
- All inbound messages validated by Zod, invalid messages return structured errors
- Sessions created with transparent keys (agent:default:{id}) and persisted to SQLite
- session.list handler returns list from database
- DB tables for sessions, messages, usage_records exist with correct columns
</success_criteria>

<output>
After completion, create `.planning/phases/02-gateway-core/02-01-SUMMARY.md`
</output>
