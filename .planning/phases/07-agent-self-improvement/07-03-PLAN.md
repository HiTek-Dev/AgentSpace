---
phase: 07-agent-self-improvement
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/cli/src/lib/pty-proxy.ts
  - packages/cli/src/components/Chat.tsx
  - packages/cli/package.json
autonomous: true

must_haves:
  truths:
    - "User can type /proxy <command> in the CLI to launch an interactive terminal application"
    - "Interactive applications (vim, git rebase, etc.) have full control of the terminal with proper raw mode"
    - "Terminal resizes are forwarded to the PTY subprocess"
    - "After the PTY subprocess exits, the CLI prints an exit message and the user can resume"
    - "Ink rendering is properly unmounted before PTY takes over to avoid raw mode conflicts"
  artifacts:
    - path: "packages/cli/src/lib/pty-proxy.ts"
      provides: "PTY proxy spawning and stdin/stdout routing"
      exports: ["runPtyProxy", "PtyProxyOptions"]
    - path: "packages/cli/src/components/Chat.tsx"
      provides: "/proxy slash command handler"
      contains: "proxy"
    - path: "packages/cli/package.json"
      provides: "node-pty dependency"
      contains: "node-pty"
  key_links:
    - from: "packages/cli/src/components/Chat.tsx"
      to: "packages/cli/src/lib/pty-proxy.ts"
      via: "runPtyProxy import for /proxy command"
      pattern: "import.*runPtyProxy.*pty-proxy"
    - from: "packages/cli/src/lib/pty-proxy.ts"
      to: "node-pty"
      via: "pty.spawn for subprocess"
      pattern: "import.*pty.*node-pty"
---

<objective>
Implement terminal proxy mode so users can run interactive CLI applications (vim, git rebase, debuggers) through the AgentSpace CLI.

Purpose: CLI-05 requires a terminal proxy mode. The user types `/proxy vim file.txt` and vim gets full TTY control. Ink must unmount to avoid raw mode conflicts with node-pty.

Output: `pty-proxy.ts` library, node-pty dependency, and `/proxy` slash command in the CLI.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/cli/src/components/Chat.tsx
@packages/cli/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install node-pty and create pty-proxy library</name>
  <files>
    packages/cli/package.json
    packages/cli/src/lib/pty-proxy.ts
  </files>
  <action>
**Install node-pty:**
```bash
cd packages/cli && pnpm add node-pty
```

node-pty is a native addon requiring Xcode command line tools on macOS (which the dev machine has). If install fails, check for `xcode-select --install`.

**Create packages/cli/src/lib/pty-proxy.ts:**

```typescript
import * as pty from "node-pty";
import * as os from "node:os";

export interface PtyProxyOptions {
  command: string;
  args?: string[];
  cwd?: string;
  cols?: number;
  rows?: number;
  env?: Record<string, string>;
}

export interface PtyProxyResult {
  exitCode: number;
}

/**
 * Spawn an interactive PTY subprocess and route stdin/stdout.
 *
 * IMPORTANT: Ink must be unmounted before calling this function.
 * node-pty requires exclusive raw mode access to stdin.
 *
 * Returns a promise that resolves when the subprocess exits.
 */
export async function runPtyProxy(opts: PtyProxyOptions): Promise<PtyProxyResult> {
  return new Promise((resolve) => {
    const shell = opts.command;
    const args = opts.args ?? [];
    const cols = opts.cols ?? process.stdout.columns ?? 80;
    const rows = opts.rows ?? process.stdout.rows ?? 24;

    const ptyProcess = pty.spawn(shell, args, {
      name: "xterm-256color",
      cols,
      rows,
      cwd: opts.cwd ?? process.cwd(),
      env: opts.env ?? (process.env as Record<string, string>),
    });

    // Forward PTY output to user's terminal
    ptyProcess.onData((data: string) => {
      process.stdout.write(data);
    });

    // Forward user input to PTY
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
    }
    process.stdin.resume();

    const onStdinData = (data: Buffer) => {
      ptyProcess.write(data.toString());
    };
    process.stdin.on("data", onStdinData);

    // Handle terminal resize
    const onResize = () => {
      ptyProcess.resize(
        process.stdout.columns ?? 80,
        process.stdout.rows ?? 24,
      );
    };
    process.stdout.on("resize", onResize);

    // Clean up on PTY exit
    ptyProcess.onExit(({ exitCode }) => {
      process.stdin.removeListener("data", onStdinData);
      process.stdout.removeListener("resize", onResize);
      if (process.stdin.isTTY) {
        process.stdin.setRawMode(false);
      }
      process.stdin.pause();
      resolve({ exitCode: exitCode ?? 0 });
    });
  });
}
```

Key design decisions:
- Use `xterm-256color` TERM for good color support
- Guard `setRawMode` behind `isTTY` check for non-interactive environments
- Clean up all listeners on exit to avoid leaks
- Return exit code for the caller to handle
  </action>
  <verify>
`cd /Users/hitekmedia/Documents/GitHub/AgentSpace && npx tsc --noEmit -p packages/cli/tsconfig.json` compiles. `ls packages/cli/node_modules/node-pty` confirms installation.
  </verify>
  <done>node-pty is installed. pty-proxy.ts exports runPtyProxy that spawns a PTY subprocess with full stdin/stdout routing and resize handling.</done>
</task>

<task type="auto">
  <name>Task 2: Add /proxy slash command to Chat component</name>
  <files>
    packages/cli/src/components/Chat.tsx
  </files>
  <action>
In the Chat component's slash command handling (where `/help`, `/model`, `/session` etc. are dispatched):

1. Add `/proxy` command detection. When user types `/proxy <command> [args...]`, parse the command and args:
   ```typescript
   if (input.startsWith("/proxy ")) {
     const parts = input.slice(7).trim().split(/\s+/);
     const command = parts[0];
     const args = parts.slice(1);
     if (!command) {
       // Show error: "Usage: /proxy <command> [args...]"
       return;
     }
     // Trigger proxy mode
   }
   ```

2. The tricky part: Ink must unmount before PTY can take over. The approach:
   - Use `useApp()` hook to get the `exit()` function
   - Store the proxy command in a ref or state
   - Call `exit()` which unmounts Ink and clears raw mode
   - After Ink unmounts, the chat command entrypoint runs the PTY

   Implementation: Add a `proxyCommand` state to Chat. When `/proxy` is entered, set `proxyCommand` to `{ command, args }` and call `exit()`. In the chat command entrypoint (the file that calls `render(<Chat ... />)`), check the return value. If the Ink app exited with a proxy command, run `runPtyProxy()`, then print a message and `process.exit(0)`.

   Since Ink's `exit()` doesn't easily pass data back, use a simpler pattern:
   - Store the proxy command in a module-level variable (or global)
   - Export a `getPendingProxy()` function from a shared module
   - After Ink unmounts in the chat command, check if there's a pending proxy

   Simplest approach: Write the proxy command to a well-known temp file, exit Ink, read the temp file in the chat command entrypoint, run PTY.

   Actually, the simplest: use `process.env` as the communication channel. Set `process.env.__AGENTSPACE_PROXY_CMD` before calling `exit()`. The chat command entrypoint reads it after Ink unmounts.

   Or even simpler: Use a callback pattern. The Chat component accepts an `onProxyRequest: (cmd: string, args: string[]) => void` prop. The chat command passes this callback. When `/proxy` fires, it calls the callback, which stores the request externally, then calls `exit()`.

   In the chat command file (likely `packages/cli/src/commands/chat.ts`):
   ```typescript
   let pendingProxy: { command: string; args: string[] } | null = null;

   const { waitUntilExit } = render(
     <Chat
       ...existingProps
       onProxyRequest={(cmd, args) => {
         pendingProxy = { command: cmd, args };
       }}
     />
   );

   await waitUntilExit();

   if (pendingProxy) {
     console.log(`\n[proxy] Running: ${pendingProxy.command} ${pendingProxy.args.join(" ")}\n`);
     const { exitCode } = await runPtyProxy({
       command: pendingProxy.command,
       args: pendingProxy.args,
     });
     console.log(`\n[proxy] Process exited with code ${exitCode}`);
     console.log("Type 'agentspace chat' to resume your session.\n");
     process.exit(exitCode);
   }
   ```

3. Add `/proxy` to the `/help` output with description: "Run an interactive terminal application (vim, git rebase, etc.)"

4. Update the Chat component props interface to include `onProxyRequest?: (command: string, args: string[]) => void`.

5. In the Chat component, when `/proxy` is detected and `onProxyRequest` exists:
   - Call `onProxyRequest(command, args)`
   - Call `exit()` from `useApp()`
   - Do NOT add any messages to chat — the transition should be clean

6. Also update the chat command file to import `runPtyProxy` from `../lib/pty-proxy.js` and handle the post-exit proxy flow.
  </action>
  <verify>
`cd /Users/hitekmedia/Documents/GitHub/AgentSpace && npx tsc --noEmit -p packages/cli/tsconfig.json` compiles. `grep -r "/proxy" packages/cli/src/` — present in Chat.tsx and help output.
  </verify>
  <done>/proxy slash command is registered. When invoked, Ink unmounts cleanly, PTY subprocess gets full terminal control, and a resume message is printed after exit.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/cli/tsconfig.json` — CLI compiles with node-pty types
2. `grep -r "node-pty" packages/cli/package.json` — dependency listed
3. `grep -r "runPtyProxy" packages/cli/src/` — imported in chat command
4. `grep -r "/proxy" packages/cli/src/` — slash command registered
5. `grep -r "onProxyRequest" packages/cli/src/` — callback prop on Chat, handled in command
</verification>

<success_criteria>
- node-pty is installed in packages/cli
- runPtyProxy spawns PTY with stdin/stdout routing and resize
- /proxy slash command parses command and args
- Ink unmounts cleanly before PTY takes over (no raw mode conflict)
- Chat command entrypoint handles post-exit proxy flow
- CLI compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-agent-self-improvement/07-03-SUMMARY.md`
</output>
