---
phase: 07-agent-self-improvement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gateway/src/agent/failure-detector.ts
  - packages/gateway/src/agent/tool-loop.ts
  - packages/gateway/src/ws/protocol.ts
autonomous: true

must_haves:
  truths:
    - "Agent detects repeated tool errors (same tool failing 3+ times) and emits a failure.detected WS message"
    - "Agent detects no-progress loops (3+ steps with no meaningful output change) and notifies the client"
    - "Agent detects max-steps-approaching condition and warns before hitting the limit"
    - "Failure detection does not stop the agent loop — it emits a notification and the agent can self-correct"
  artifacts:
    - path: "packages/gateway/src/agent/failure-detector.ts"
      provides: "Failure pattern classification from step history"
      exports: ["classifyFailurePattern", "FailurePattern", "StepRecord"]
    - path: "packages/gateway/src/agent/tool-loop.ts"
      provides: "Agent loop with onStepFinish failure tracking"
      contains: "classifyFailurePattern"
    - path: "packages/gateway/src/ws/protocol.ts"
      provides: "failure.detected server message schema"
      contains: "failure.detected"
  key_links:
    - from: "packages/gateway/src/agent/tool-loop.ts"
      to: "packages/gateway/src/agent/failure-detector.ts"
      via: "classifyFailurePattern import"
      pattern: "import.*classifyFailurePattern.*failure-detector"
    - from: "packages/gateway/src/agent/tool-loop.ts"
      to: "packages/gateway/src/ws/protocol.ts"
      via: "failure.detected message send"
      pattern: "failure\\.detected"
---

<objective>
Implement failure pattern detection in the agent tool loop so the agent can recognize when it is stuck and propose corrective actions.

Purpose: AGNT-06 requires the agent to detect its own failure patterns during task execution. This is instrumentation layered on the existing `runAgentLoop` using AI SDK's `onStepFinish` hook and a pure classification function.

Output: `failure-detector.ts` with pattern classification, updated `tool-loop.ts` with step tracking, and `failure.detected` WS protocol message.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/gateway/src/agent/tool-loop.ts
@packages/gateway/src/ws/protocol.ts
@packages/gateway/src/ws/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create failure-detector.ts with pattern classification</name>
  <files>packages/gateway/src/agent/failure-detector.ts</files>
  <action>
Create `packages/gateway/src/agent/failure-detector.ts` with:

1. `StepRecord` interface capturing the fields from AI SDK's `onStepFinish`:
   - `stepType: string` (initial, continue, tool-result)
   - `finishReason: string` (stop, tool-calls, error, length)
   - `toolCalls?: Array<{ toolName: string; input: unknown }>`
   - `toolResults?: Array<{ toolName: string; output: unknown }>`
   - `text?: string`

2. `FailurePattern` interface:
   - `pattern: "repeated-tool-error" | "no-progress" | "max-steps-approaching" | "tool-rejection-loop"`
   - `description: string` (human-readable explanation)
   - `suggestedAction: string` (what the agent should do)
   - `affectedTool?: string` (which tool is involved, if applicable)

3. `classifyFailurePattern(steps: StepRecord[], maxSteps?: number): FailurePattern | null` — pure function:
   - **repeated-tool-error**: Check last 3 steps. If all have `toolCalls` with the same `toolName` AND all `toolResults` contain error-like output (check for `error`, `Error`, `ENOENT`, `EACCES`, `denied`, `failed` in stringified output), return pattern with `affectedTool` set.
   - **no-progress**: Check last 3 steps. If all have `finishReason === "tool-calls"` and their `toolResults` stringified outputs are identical (or all empty), return pattern.
   - **max-steps-approaching**: If `steps.length >= (maxSteps ?? 10) - 1`, return pattern.
   - **tool-rejection-loop**: Check last 3 steps. If all have tool calls where none produced results (no toolResults at all — indicating approval was denied), return pattern.
   - Return `null` if no pattern detected.
   - Check patterns in priority order: repeated-tool-error > tool-rejection-loop > no-progress > max-steps-approaching.

Export all types and the function. Use `createLogger("failure-detector")` for debug logging.
  </action>
  <verify>
`cd /Users/hitekmedia/Documents/GitHub/AgentSpace && npx tsc --noEmit -p packages/gateway/tsconfig.json` compiles without errors.
  </verify>
  <done>failure-detector.ts exists with StepRecord, FailurePattern types and classifyFailurePattern function that classifies 4 failure patterns from step history.</done>
</task>

<task type="auto">
  <name>Task 2: Wire failure detection into tool-loop and add WS protocol message</name>
  <files>
    packages/gateway/src/agent/tool-loop.ts
    packages/gateway/src/ws/protocol.ts
  </files>
  <action>
**protocol.ts changes:**

Add a `FailureDetectedSchema` to the server messages section:
```
const FailureDetectedSchema = z.object({
  type: z.literal("failure.detected"),
  requestId: z.string(),
  pattern: z.enum(["repeated-tool-error", "no-progress", "max-steps-approaching", "tool-rejection-loop"]),
  description: z.string(),
  suggestedAction: z.string(),
  affectedTool: z.string().optional(),
});
```
Add it to the `ServerMessageSchema` discriminated union. Add `"failure.detected"` to the `ServerMessage` type.

**tool-loop.ts changes:**

1. Import `classifyFailurePattern` and `StepRecord` from `./failure-detector.js`.
2. Inside `runAgentLoop`, before the `streamText` call, create `const stepHistory: StepRecord[] = [];`.
3. Add `onStepFinish` callback to the `streamText` options:
   ```typescript
   onStepFinish: async ({ stepType, finishReason, toolCalls, toolResults, text }) => {
     stepHistory.push({ stepType, finishReason, toolCalls, toolResults, text });
     const failure = classifyFailurePattern(stepHistory, maxSteps);
     if (failure) {
       send(socket, {
         type: "failure.detected",
         requestId,
         pattern: failure.pattern,
         description: failure.description,
         suggestedAction: failure.suggestedAction,
         ...(failure.affectedTool ? { affectedTool: failure.affectedTool } : {}),
       });
     }
   },
   ```
4. Keep the existing `finish-step` case in `fullStream` iteration for logging — `onStepFinish` runs in addition to the stream iteration.

Do NOT modify the `stopWhen` — failure detection is informational, not an interrupt. The agent receives the failure pattern in its context and can self-correct.

Add `failure-detector.js` to `packages/gateway/src/agent/index.ts` barrel export.
  </action>
  <verify>
`cd /Users/hitekmedia/Documents/GitHub/AgentSpace && npx tsc --noEmit -p packages/gateway/tsconfig.json` compiles without errors. Grep for `failure.detected` in protocol.ts and tool-loop.ts to confirm wiring.
  </verify>
  <done>Agent loop tracks step history via onStepFinish, classifies failure patterns after each step, and emits failure.detected WS messages to the client. Protocol schema includes the new message type.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/gateway/tsconfig.json` — no type errors
2. `grep -r "classifyFailurePattern" packages/gateway/src/` — imported and called in tool-loop.ts
3. `grep -r "failure.detected" packages/gateway/src/` — in protocol.ts schema and tool-loop.ts send
4. `grep -r "onStepFinish" packages/gateway/src/agent/tool-loop.ts` — present in streamText options
</verification>

<success_criteria>
- failure-detector.ts exports classifyFailurePattern with 4 pattern types
- tool-loop.ts accumulates step history and calls classifier after each step
- failure.detected is a valid server message in the WS protocol
- Gateway compiles cleanly with no type errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-agent-self-improvement/07-01-SUMMARY.md`
</output>
