---
phase: 07-agent-self-improvement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/core/src/skills/writer.ts
  - packages/core/src/skills/index.ts
  - packages/gateway/src/tools/skill.ts
  - packages/gateway/src/tools/index.ts
  - packages/gateway/src/agent/tool-registry.ts
  - packages/gateway/src/ws/protocol.ts
  - packages/cli/src/components/SkillApprovalPrompt.tsx
  - packages/cli/src/components/Chat.tsx
autonomous: true

must_haves:
  truths:
    - "Agent can draft a new SKILL.md file via a skill_draft tool call"
    - "Drafted skill is written to a sandbox temp directory, not directly to the skills directory"
    - "User sees a SkillApprovalPrompt in the CLI showing the drafted skill name, description, and instructions"
    - "On approval, skill_register copies the skill from sandbox to workspace skills directory"
    - "skill_register requires 'always' approval tier — agent cannot bypass user review"
  artifacts:
    - path: "packages/core/src/skills/writer.ts"
      provides: "writeSkill function for creating SKILL.md files"
      exports: ["writeSkill"]
    - path: "packages/gateway/src/tools/skill.ts"
      provides: "skill_draft and skill_register AI SDK tool definitions"
      exports: ["createSkillDraftTool", "createSkillRegisterTool"]
    - path: "packages/cli/src/components/SkillApprovalPrompt.tsx"
      provides: "Ink component for reviewing and approving agent-drafted skills"
      exports: ["SkillApprovalPrompt"]
    - path: "packages/gateway/src/ws/protocol.ts"
      provides: "skill.proposed and skill.registered server message schemas"
      contains: "skill.proposed"
  key_links:
    - from: "packages/gateway/src/tools/skill.ts"
      to: "packages/core/src/skills/writer.ts"
      via: "writeSkill import"
      pattern: "import.*writeSkill.*writer"
    - from: "packages/gateway/src/agent/tool-registry.ts"
      to: "packages/gateway/src/tools/skill.ts"
      via: "skill tools added to registry"
      pattern: "skill_draft|skill_register"
    - from: "packages/gateway/src/tools/skill.ts"
      to: "packages/gateway/src/agent/approval-gate.ts"
      via: "skill_register has always tier"
      pattern: "skill_register.*always"
---

<objective>
Implement agent skill authoring with sandbox testing and user approval gates so the agent can draft new skills, have them reviewed, and register them on approval.

Purpose: AGNT-07 and AGNT-08 require the agent to author skills and get user approval before registration. This builds on the existing SKILL.md format from Phase 6 and the approval gate system.

Output: Core skill writer, gateway skill tools (draft + register), WS protocol extensions, and CLI skill approval prompt.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/core/src/skills/types.ts
@packages/core/src/skills/loader.ts
@packages/gateway/src/tools/index.ts
@packages/gateway/src/agent/tool-registry.ts
@packages/gateway/src/agent/approval-gate.ts
@packages/gateway/src/ws/protocol.ts
@packages/cli/src/components/ToolApprovalPrompt.tsx
@packages/cli/src/components/Chat.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core skill writer and gateway skill tools</name>
  <files>
    packages/core/src/skills/writer.ts
    packages/core/src/skills/index.ts
    packages/gateway/src/tools/skill.ts
    packages/gateway/src/tools/index.ts
  </files>
  <action>
**packages/core/src/skills/writer.ts:**

Create a `writeSkill` function:
```typescript
import { writeFileSync, mkdirSync } from "node:fs";
import { join } from "node:path";
import matter from "gray-matter";
import type { SkillMetadata } from "./types.js";

export function writeSkill(
  skillsDir: string,
  metadata: SkillMetadata,
  instructions: string,
): string {
  const skillDir = join(skillsDir, metadata.name);
  mkdirSync(skillDir, { recursive: true });

  const content = matter.stringify(instructions, {
    name: metadata.name,
    description: metadata.description,
    tier: metadata.tier ?? "workspace",
    version: metadata.version ?? "1.0.0",
    tools: metadata.tools ?? [],
    triggers: metadata.triggers ?? [],
  });

  const skillPath = join(skillDir, "SKILL.md");
  writeFileSync(skillPath, content, "utf-8");
  return skillPath;
}
```

Add `writeSkill` to `packages/core/src/skills/index.ts` barrel export.

**packages/gateway/src/tools/skill.ts:**

Create two AI SDK tool definitions:

1. `createSkillDraftTool(sandboxDir: string)` — returns `tool()` with:
   - `description`: "Draft a new skill as a SKILL.md file in a sandbox directory for user review. Use this when you've identified a recurring task pattern that should become a reusable skill."
   - `inputSchema`: z.object with `name` (z.string, slug format), `description` (z.string, one sentence), `instructions` (z.string, full markdown instructions), `tools` (z.array(z.string()).optional(), tools the skill needs), `triggers` (z.array(z.string()).optional(), when to activate)
   - `execute`: calls `writeSkill(sandboxDir, { name, description, tier: "workspace", tools, triggers }, instructions)`. Returns `{ skillPath, name, description, status: "drafted" }`.
   - Import `writeSkill` from `@agentspace/core`.

2. `createSkillRegisterTool(sandboxDir: string, workspaceSkillsDir: string)` — returns `tool()` with:
   - `description`: "Register a previously drafted skill by copying it from the sandbox to the workspace skills directory. Requires user approval."
   - `inputSchema`: z.object with `name` (z.string, the skill name from a prior skill_draft call)
   - `execute`: reads the SKILL.md from `sandboxDir/<name>/SKILL.md`, copies (writes) to `workspaceSkillsDir/<name>/SKILL.md` using `mkdirSync` + `copyFileSync`. Returns `{ name, registeredPath, status: "registered" }`. Throws if source doesn't exist.

Export both factory functions.

**packages/gateway/src/tools/index.ts:**

Re-export from `./skill.js`.
  </action>
  <verify>
`cd /Users/hitekmedia/Documents/GitHub/AgentSpace && npx tsc --noEmit -p packages/core/tsconfig.json && npx tsc --noEmit -p packages/gateway/tsconfig.json` — both compile.
  </verify>
  <done>writeSkill in core creates valid SKILL.md files. skill_draft tool writes to sandbox. skill_register tool copies from sandbox to workspace. Both compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire skill tools into registry, protocol, and approval gate</name>
  <files>
    packages/gateway/src/agent/tool-registry.ts
    packages/gateway/src/ws/protocol.ts
  </files>
  <action>
**tool-registry.ts changes:**

In the tool registry building function, after the existing built-in tools (filesystem, shell) and MCP tools:

1. Import `createSkillDraftTool` and `createSkillRegisterTool` from `../tools/skill.js`.
2. Create a sandbox temp directory: `const sandboxDir = join(os.tmpdir(), "agentspace-skill-sandbox-" + crypto.randomUUID())`. Import `os` from `node:os` and `crypto` from `node:crypto`.
3. Resolve the workspace skills directory from config using `getSkillsDirs` from `@agentspace/core`. If no workspace dir is available, use `join(os.homedir(), ".config", "agentspace", "skills")` as fallback.
4. Add `skill_draft: createSkillDraftTool(sandboxDir)` and `skill_register: createSkillRegisterTool(sandboxDir, workspaceSkillsDir)` to the tools record.
5. In the approval policy `perTool` map, set `"skill_register": "always"` to enforce user approval. `skill_draft` can use the default tier (session or auto — drafting is safe since it only writes to a temp dir).

**protocol.ts changes:**

Add two new server message schemas:

```typescript
const SkillProposedSchema = z.object({
  type: z.literal("skill.proposed"),
  requestId: z.string(),
  name: z.string(),
  description: z.string(),
  instructions: z.string(),
  sandboxPath: z.string(),
});

const SkillRegisteredSchema = z.object({
  type: z.literal("skill.registered"),
  requestId: z.string(),
  name: z.string(),
  registeredPath: z.string(),
});
```

Add both to the `ServerMessageSchema` discriminated union.

Note: The `skill.proposed` message is sent by `skill_draft`'s execute function as a side-effect (it already sends via tool result, but also emit a WS notification for the CLI to show the approval prompt). Actually, the simpler path: the existing `tool.approval.request` for `skill_register` already triggers `ToolApprovalPrompt`. We just need `skill.proposed` as an informational message showing the drafted content. Add a WS `send()` call inside `createSkillDraftTool`'s execute to emit `skill.proposed` — this requires passing the `socket` and `requestId` into the tool factory. Update `createSkillDraftTool` to accept `socket: WebSocket` and `requestId: string` in its options (or pass a `notify` callback: `(msg: ServerMessage) => void`).

Better pattern: pass a `notify: (msg: ServerMessage) => void` callback to both tool factories. `createSkillDraftTool` calls `notify({ type: "skill.proposed", ... })` after writing. `createSkillRegisterTool` calls `notify({ type: "skill.registered", ... })` after copying.

Update `createSkillDraftTool(sandboxDir, notify)` and `createSkillRegisterTool(sandboxDir, workspaceSkillsDir, notify)` signatures. In tool-registry.ts, pass `(msg) => send(socket, msg)` as the notify callback — but the socket isn't available at registry build time. Instead, store the notify callback on ConnectionState or use a lazy pattern. Simplest: make the tool factories accept a `getNotify: () => (msg: ServerMessage) => void` thunk that is resolved at execute time from the connection state.

Actually, simplest approach: the tool result already flows through the agent loop as a `tool-result` part, and the CLI already renders tool results. The `skill.proposed` WS message is a bonus notification. For MVP, skip the custom WS message — the tool-result from `skill_draft` contains `{ name, description, status: "drafted" }` which is enough. The `tool.approval.request` for `skill_register` (with `always` tier) shows the ToolApprovalPrompt. This is sufficient.

Remove the `skill.proposed` and `skill.registered` schemas — they add complexity with no MVP benefit. The existing tool.call/tool.result + tool.approval.request flow handles everything.

So the protocol.ts changes for this plan: NONE needed (the skill.proposed/registered messages are a nice-to-have, not required). The approval gate's `"skill_register": "always"` in perTool is the critical wiring.

Update tool-registry.ts only:
1. Import skill tool factories
2. Create sandbox dir
3. Resolve workspace skills dir
4. Add both tools to the registry
5. Set `skill_register` to `always` tier in approval policy
  </action>
  <verify>
`cd /Users/hitekmedia/Documents/GitHub/AgentSpace && npx tsc --noEmit -p packages/gateway/tsconfig.json` — compiles. `grep -r "skill_register" packages/gateway/src/agent/tool-registry.ts` — present. `grep -r "skill_draft" packages/gateway/src/agent/tool-registry.ts` — present.
  </verify>
  <done>skill_draft and skill_register tools are registered in the tool registry. skill_register has "always" approval tier. Sandbox dir is created per-connection. Workspace skills dir is resolved from config.</done>
</task>

<task type="auto">
  <name>Task 3: Create SkillApprovalPrompt CLI component with enhanced skill display</name>
  <files>
    packages/cli/src/components/SkillApprovalPrompt.tsx
    packages/cli/src/components/Chat.tsx
  </files>
  <action>
**packages/cli/src/components/SkillApprovalPrompt.tsx:**

Create an Ink component that enhances the existing tool approval flow for skill_register calls. This component is shown when a `tool.approval.request` arrives where `toolName === "skill_register"`.

The component should:
1. Accept props: `toolCallId: string`, `toolName: string`, `args: Record<string, unknown>`, `onRespond: (approved: boolean) => void`
2. Display a box with border and title "Skill Registration Approval"
3. Show the skill name from `args.name`
4. Show instructions: "Press Y to approve, N to deny"
5. Use `useInput` from Ink to handle Y/N keypresses
6. Call `onRespond(true)` on Y, `onRespond(false)` on N

This is essentially the same pattern as `ToolApprovalPrompt.tsx` but with a header that says "Skill Registration" and displays the skill name prominently. If the existing ToolApprovalPrompt already handles this case well (it shows toolName and args), then this file can be a thin wrapper or the Chat.tsx can just use ToolApprovalPrompt directly for skill approvals.

Check the existing ToolApprovalPrompt.tsx. If it already shows toolName + args generically, then creating a separate component is unnecessary — the existing flow works. In that case, create SkillApprovalPrompt.tsx as a wrapper that adds a header ("Agent wants to register a new skill") and renders the skill name/description from the args more prominently than the generic JSON dump, then delegates to the same onRespond callback.

**packages/cli/src/components/Chat.tsx:**

In the section that handles `tool.approval.request` messages, add a condition:
- If `toolName === "skill_register"`, render `<SkillApprovalPrompt>` instead of the generic `<ToolApprovalPrompt>`
- Otherwise render the existing `<ToolApprovalPrompt>`

Import `SkillApprovalPrompt` from `./SkillApprovalPrompt.js`.
  </action>
  <verify>
`cd /Users/hitekmedia/Documents/GitHub/AgentSpace && npx tsc --noEmit -p packages/cli/tsconfig.json` — compiles. `grep -r "SkillApprovalPrompt" packages/cli/src/` — imported in Chat.tsx.
  </verify>
  <done>SkillApprovalPrompt component exists and is rendered for skill_register approval requests. The user sees the skill name prominently and can approve/deny. The existing approval flow handles the rest.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/core/tsconfig.json` — core compiles with writeSkill
2. `npx tsc --noEmit -p packages/gateway/tsconfig.json` — gateway compiles with skill tools and registry wiring
3. `npx tsc --noEmit -p packages/cli/tsconfig.json` — CLI compiles with SkillApprovalPrompt
4. `grep -r "skill_draft\|skill_register" packages/gateway/src/` — both tools registered
5. `grep -r '"always"' packages/gateway/src/agent/tool-registry.ts` — skill_register has always tier
6. `grep -r "writeSkill" packages/core/src/skills/` — exported from core
</verification>

<success_criteria>
- writeSkill creates valid SKILL.md files with gray-matter frontmatter
- skill_draft tool writes to sandbox temp directory
- skill_register tool copies from sandbox to workspace skills directory
- skill_register requires "always" approval tier
- SkillApprovalPrompt renders for skill_register approval requests
- All three packages compile cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-agent-self-improvement/07-02-SUMMARY.md`
</output>
