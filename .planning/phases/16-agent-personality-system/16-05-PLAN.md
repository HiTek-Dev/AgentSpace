---
phase: 16-agent-personality-system
plan: 05
type: execute
wave: 3
depends_on: ["16-03"]
files_modified:
  - packages/gateway/src/ws/handlers.ts
  - packages/db/src/memory/identity-manager.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "Migration runs automatically on first getMemoryContext() call"
    - "AGENTS.md only loaded when config.agents.list has more than 1 entry"
    - "Identity loaders accept optional agentId for per-agent resolution"
    - "All identity file changes go through @tek/db, never direct reads in gateway"
  artifacts:
    - path: "packages/db/src/memory/identity-manager.ts"
      provides: "agentId-aware loaders using resolveIdentityFile cascade"
      contains: "resolveIdentityFile"
    - path: "packages/gateway/src/ws/handlers.ts"
      provides: "Migration trigger on first chat.send"
      contains: "migrateToMultiFile"
  key_links:
    - from: "packages/db/src/memory/identity-manager.ts"
      to: "packages/db/src/memory/agent-resolver.ts"
      via: "resolveIdentityFile() for agent-aware loading"
      pattern: "resolveIdentityFile"
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "packages/db/src/memory/migration.ts"
      via: "migrateToMultiFile() on first chat.send"
      pattern: "migrateToMultiFile"
---

<objective>
Wire agent-aware identity loading, conditional AGENTS.md loading, and automatic migration trigger. This plan integrates the multi-agent isolation with the identity loading pipeline.

Purpose: Completes the multi-agent identity system by making loaders agent-aware, preventing unnecessary token usage for single-agent setups, and ensuring migration runs seamlessly on upgrade.
Output: Agent-aware loaders, conditional AGENTS.md loading, migration trigger in handlers.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-agent-personality-system/16-01-SUMMARY.md
@.planning/phases/16-agent-personality-system/16-02-SUMMARY.md
@.planning/phases/16-agent-personality-system/16-03-SUMMARY.md
@packages/db/src/memory/identity-manager.ts
@packages/db/src/memory/agent-resolver.ts
@packages/gateway/src/ws/handlers.ts
@packages/gateway/src/memory/memory-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make identity loaders agent-aware with cascade resolution</name>
  <files>packages/db/src/memory/identity-manager.ts</files>
  <action>
    Update all 4 loader functions in identity-manager.ts to accept optional `agentId` parameter and use cascade resolution:

    ```typescript
    import { resolveIdentityFile } from "./agent-resolver.js";
    ```

    For each loader (loadIdentity, loadStyle, loadUser, loadAgentsConfig):
    - Add `agentId?: string` parameter
    - When agentId is provided and not "default", use `resolveIdentityFile(agentId, filename)` which does cascade resolution
    - When agentId is undefined or "default", keep existing behavior (ensureMemoryFile + global path read)
    - loadUser() does NOT use agentId (USER.md is shared across agents, always loads from global or shared)

    Updated signatures:
    ```typescript
    export function loadIdentity(agentId?: string): string
    export function loadStyle(agentId?: string): string
    export function loadUser(): string  // no agentId, always shared
    export function loadAgentsConfig(): string  // no agentId, always global
    ```

    Implementation pattern for agent-aware loaders:
    ```typescript
    export function loadIdentity(agentId?: string): string {
      if (agentId && agentId !== "default") {
        const content = resolveIdentityFile(agentId, "IDENTITY.md");
        if (content) return content;
      }
      // Fallback to global (seeds template if needed)
      ensureMemoryFile("IDENTITY.md", "IDENTITY.md");
      if (!existsSync(IDENTITY_PATH)) return "";
      return readFileSync(IDENTITY_PATH, "utf-8");
    }
    ```

    Same pattern for loadStyle with STYLE.md.
  </action>
  <verify>Run `npx tsc --noEmit` from packages/db/. Verify loadIdentity and loadStyle accept agentId. Verify loadUser and loadAgentsConfig do NOT accept agentId.</verify>
  <done>loadIdentity(agentId?) and loadStyle(agentId?) use cascade resolution for non-default agents. loadUser() and loadAgentsConfig() always load from global (shared). All backward-compatible.</done>
</task>

<task type="auto">
  <name>Task 2: Wire migration trigger and conditional AGENTS.md loading</name>
  <files>
    packages/gateway/src/ws/handlers.ts
    packages/gateway/src/memory/memory-manager.ts
  </files>
  <action>
    1. In `packages/gateway/src/ws/handlers.ts`, add a module-level migration flag and call:
       ```typescript
       import { migrateToMultiFile } from "@tek/db";

       let migrationRan = false;

       function ensureMigration(): void {
         if (migrationRan) return;
         migrationRan = true;
         try {
           const result = migrateToMultiFile();
           if (result.migrated) {
             logger.info(`Identity files migrated to v2 (backup: ${result.backup})`);
           }
         } catch (err) {
           logger.warn(`Migration failed (non-fatal): ${err}`);
         }
       }
       ```
       Call `ensureMigration()` at the beginning of `handleChatSend()` (before context assembly). This ensures migration runs once on the first chat message after upgrade.

    2. In `packages/gateway/src/memory/memory-manager.ts`, make AGENTS.md loading conditional:
       ```typescript
       import { loadConfig } from "@tek/core";

       // In getMemoryContext():
       const config = loadConfig();
       const agentsList = config?.agents?.list ?? [];
       const agents = agentsList.length > 1 ? loadAgentsConfig() : "";
       ```
       This saves tokens for single-agent users by not loading AGENTS.md when there's only one (or zero) agents configured.

    3. Pass agentId through the MemoryManager:
       ```typescript
       getMemoryContext(agentId?: string): { ... } {
         return {
           soul: loadSoul(agentId),
           identity: loadIdentity(agentId),
           style: loadStyle(agentId),
           user: loadUser(),  // always shared
           agents: agentsList.length > 1 ? loadAgentsConfig() : "",
           longTermMemory: loadLongTermMemory(),
           recentLogs: loadRecentLogs(),
         };
       }
       ```
  </action>
  <verify>Run `npx tsc --noEmit` from packages/gateway/. Verify ensureMigration() called in handleChatSend. Verify AGENTS.md loading is conditional on agents.list length.</verify>
  <done>Migration runs automatically on first chat.send (once, non-blocking). AGENTS.md only loaded when multiple agents configured. agentId flows through MemoryManager to all agent-aware loaders.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes from both packages/db/ and packages/gateway/
- `grep "ensureMigration" packages/gateway/src/ws/handlers.ts` shows migration trigger
- `grep "agentsList.length" packages/gateway/src/memory/memory-manager.ts` shows conditional AGENTS.md
- `grep "resolveIdentityFile" packages/db/src/memory/identity-manager.ts` shows cascade resolution
</verification>

<success_criteria>
- Identity loaders are agent-aware (cascade resolution for non-default agents)
- USER.md and AGENTS.md always load from global (not per-agent)
- AGENTS.md only loaded when config has multiple agents (token efficiency)
- Migration runs once on first chat.send after upgrade
- Migration failure is non-fatal (logged, not thrown)
- agentId flows from handler through MemoryManager to @tek/db loaders
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-agent-personality-system/16-05-SUMMARY.md`
</output>
