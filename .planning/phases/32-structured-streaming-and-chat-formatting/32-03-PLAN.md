---
phase: 32-structured-streaming-and-chat-formatting
plan: 03
type: execute
wave: 2
depends_on:
  - 32-01
files_modified:
  - packages/cli/src/hooks/useChat.ts
  - packages/cli/src/components/StreamingResponse.tsx
  - packages/cli/src/components/MessageBubble.tsx
  - packages/cli/src/lib/gateway-client.ts
autonomous: true
requirements:
  - STRM-05
  - STRM-07

must_haves:
  truths:
    - "CLI displays reasoning text as dimmed italic inline during streaming"
    - "CLI displays reasoning in completed message history as dimmed italic with ~ prefix"
    - "CLI displays source attributions as dimmed link text after assistant messages"
    - "New protocol message types handled without errors in CLI switch statement"
  artifacts:
    - path: "packages/cli/src/hooks/useChat.ts"
      provides: "Reasoning accumulation and source collection in CLI chat state"
      contains: "chat.stream.reasoning"
    - path: "packages/cli/src/components/StreamingResponse.tsx"
      provides: "Inline reasoning display during streaming"
      contains: "reasoningText"
    - path: "packages/cli/src/components/MessageBubble.tsx"
      provides: "Reasoning and sources rendering in completed messages"
      contains: "sources"
    - path: "packages/cli/src/lib/gateway-client.ts"
      provides: "SourceMessage type in ChatMessage union"
      contains: "SourceMessage"
  key_links:
    - from: "packages/cli/src/hooks/useChat.ts"
      to: "@tek/gateway ServerMessage"
      via: "handleServerMessage switch on msg.type"
      pattern: "chat\\.stream\\.reasoning"
    - from: "packages/cli/src/components/StreamingResponse.tsx"
      to: "useChat streamingReasoning state"
      via: "reasoningText prop"
      pattern: "reasoningText"
---

<objective>
Add reasoning block and source attribution display to the CLI chat interface, handling the new structured streaming message types from the gateway.

Purpose: CLI users see AI reasoning as dimmed italic text (unobtrusive transparency) and source citations as dimmed links, maintaining the CLI's clean aesthetic while surfacing structured content.

Output: Updated CLI useChat hook, StreamingResponse with reasoning display, MessageBubble with reasoning and sources rendering.
</objective>

<execution_context>
@/Users/drew-mini/.claude/get-shit-done/workflows/execute-plan.md
@/Users/drew-mini/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-structured-streaming-and-chat-formatting/32-RESEARCH.md
@.planning/phases/32-structured-streaming-and-chat-formatting/32-01-SUMMARY.md
@packages/cli/src/hooks/useChat.ts
@packages/cli/src/components/StreamingResponse.tsx
@packages/cli/src/components/MessageBubble.tsx
@packages/cli/src/lib/gateway-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend CLI gateway-client types and update useChat for reasoning/source handling</name>
  <files>
    packages/cli/src/lib/gateway-client.ts
    packages/cli/src/hooks/useChat.ts
  </files>
  <action>
**In `packages/cli/src/lib/gateway-client.ts`:**

1. Add a `SourceMessage` type to the ChatMessage union (after `ReasoningMessage`):
```typescript
export type SourceMessage = ChatMessageBase & {
  type: "sources";
  sources: Array<{ url: string; title?: string }>;
};
```

2. Update the `ChatMessage` union to include it:
```typescript
export type ChatMessage =
  | TextMessage
  | ToolCallMessage
  | BashCommandMessage
  | ReasoningMessage
  | SourceMessage;
```

**In `packages/cli/src/hooks/useChat.ts`:**

1. Add `streamingReasoning` state:
```typescript
const [streamingReasoning, setStreamingReasoning] = useState("");
```

2. Add `pendingSources` ref:
```typescript
const [pendingSources, setPendingSources] = useState<Array<{ url: string; title?: string }>>([]);
```

3. In `handleServerMessage`, add cases for the new message types:

For `chat.stream.reasoning`:
```typescript
case "chat.stream.reasoning":
  setStreamingReasoning((prev) => prev + msg.delta);
  break;
```

For `chat.stream.source`:
```typescript
case "chat.stream.source":
  setPendingSources((prev) => [...prev, msg.source]);
  break;
```

Note: The CLI imports `ServerMessage` from `@tek/gateway`, which will now include the new types after Plan 01 extends protocol.ts. The switch statement already has a default fallthrough, so even before this change it won't crash. These new cases simply enable explicit handling.

4. In the `chat.stream.start` handler, clear reasoning/sources state:
```typescript
setStreamingReasoning("");
setPendingSources([]);
```

5. In the `chat.stream.end` handler, after promoting streaming text to a completed message:
  - If `streamingReasoning` is non-empty, add a `ReasoningMessage` BEFORE the assistant text message:
```typescript
// Inside the setStreamingText callback, before adding the assistant message:
if (streamingReasoning) {
  const reasoningMsg: ReasoningMessage = {
    id: nanoid(),
    type: "reasoning",
    content: streamingReasoning,
    timestamp: new Date().toISOString(),
  };
  setMessages((prev) => [...prev, reasoningMsg]);
}
```
  - If `pendingSources` has entries, add a `SourceMessage` AFTER the assistant text message:
```typescript
if (pendingSources.length > 0) {
  const sourceMsg: SourceMessage = {
    id: nanoid(),
    type: "sources",
    sources: [...pendingSources],
    timestamp: new Date().toISOString(),
  };
  setMessages((prev) => [...prev, sourceMsg]);
}
```
  - Clear: `setStreamingReasoning("")`, `setPendingSources([])`

IMPORTANT: Import `ReasoningMessage` and `SourceMessage` from `../lib/gateway-client.js`.

6. Add `streamingReasoning` to the returned object.

7. In the `error` handler, also clear reasoning state:
```typescript
setStreamingReasoning("");
setPendingSources([]);
```
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/cli/tsconfig.json` to confirm no TypeScript errors. Verify `handleServerMessage` handles `chat.stream.reasoning` and `chat.stream.source` cases.
  </verify>
  <done>
CLI gateway-client.ts has SourceMessage in ChatMessage union. useChat.ts accumulates reasoning and sources during streaming, promotes to messages on stream end. streamingReasoning is exposed in the return object. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update StreamingResponse and MessageBubble to render reasoning and sources</name>
  <files>
    packages/cli/src/components/StreamingResponse.tsx
    packages/cli/src/components/MessageBubble.tsx
  </files>
  <action>
**In `packages/cli/src/components/StreamingResponse.tsx`:**

1. Add `reasoningText` prop:
```typescript
interface StreamingResponseProps {
  text: string;
  reasoningText?: string;
  model?: string;
}
```

2. When `reasoningText` is non-empty, render it ABOVE the streaming text as dimmed italic (truncated preview):
```typescript
export function StreamingResponse({ text, reasoningText, model }: StreamingResponseProps) {
  const reasoningPreview = reasoningText && reasoningText.length > 120
    ? reasoningText.slice(0, 117) + "..."
    : reasoningText;

  return (
    <Box flexDirection="column">
      <Box>
        <Text bold color="magenta">{"* Assistant"}</Text>
        {model && <Text dimColor> ({model})</Text>}
      </Box>
      {reasoningPreview && (
        <Box>
          <Text dimColor italic>{"~ "}{reasoningPreview}</Text>
        </Box>
      )}
      {text ? (
        <Text>{text}</Text>
      ) : (
        <Spinner label="Thinking..." />
      )}
    </Box>
  );
}
```

3. Update the parent component(s) that render `StreamingResponse` to pass `reasoningText={streamingReasoning}`. Find the Chat component (likely `packages/cli/src/components/Chat.tsx`) and update the StreamingResponse usage:
```typescript
<StreamingResponse
  text={streamingText}
  reasoningText={streamingReasoning}
  model={model}
/>
```

**In `packages/cli/src/components/MessageBubble.tsx`:**

1. Add a `sources` case to the switch statement for the new `SourceMessage` type:
```typescript
case "sources": {
  const items = message.sources.map((s, i) =>
    `  [${i + 1}] ${s.title || s.url}`
  ).join("\n");
  return (
    <Box marginBottom={1}>
      <Text dimColor>{"ðŸ“Ž Sources:\n"}{items}</Text>
    </Box>
  );
}
```

Note: The existing `reasoning` case in MessageBubble already renders reasoning messages as dimmed italic with `~ ` prefix. No changes needed there -- it already handles the `ReasoningMessage` type correctly from Phase 3/6 forward-compatible design.

2. Verify the existing `reasoning` case handles it properly. It already does:
```typescript
case "reasoning": {
  const preview = message.content.length > 80
    ? message.content.slice(0, 77) + "..."
    : message.content;
  return (
    <Box>
      <Box justifyContent="space-between" width="100%">
        <Text dimColor italic>{"~ "}{preview}</Text>
        {ts}
      </Box>
    </Box>
  );
}
```
This is correct. No changes needed for reasoning in MessageBubble.
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/cli/tsconfig.json` to confirm no TypeScript errors. Verify StreamingResponse accepts reasoningText prop. Verify MessageBubble handles sources case. Verify Chat.tsx passes streamingReasoning to StreamingResponse.
  </verify>
  <done>
StreamingResponse shows reasoning as dimmed italic preview during streaming. MessageBubble renders sources as a dimmed list with numbered links. Existing reasoning case already handles completed reasoning messages. Chat.tsx passes streamingReasoning to StreamingResponse. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/cli/tsconfig.json` passes with zero errors
2. StreamingResponse renders reasoning text as dimmed italic above streaming content
3. MessageBubble handles `sources` message type with dimmed link list
4. useChat accumulates reasoning/sources during streaming and promotes to messages on end
5. No unhandled switch cases for new message types
</verification>

<success_criteria>
- CLI streaming shows reasoning as dimmed italic text with ~ prefix (truncated to 120 chars)
- Completed reasoning messages appear in history as dimmed italic with timestamp
- Source attributions appear as dimmed numbered list after assistant messages
- All existing CLI chat functionality (text, tool calls, preflight, approval) unchanged
- No new dependencies required
</success_criteria>

<output>
After completion, create `.planning/phases/32-structured-streaming-and-chat-formatting/32-03-SUMMARY.md`
</output>
