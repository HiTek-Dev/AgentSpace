---
phase: 32-structured-streaming-and-chat-formatting
plan: 02
type: execute
wave: 2
depends_on:
  - 32-01
files_modified:
  - apps/desktop/src/lib/gateway-client.ts
  - apps/desktop/src/hooks/useChat.ts
  - apps/desktop/src/components/ReasoningBlock.tsx
  - apps/desktop/src/components/MessageCard.tsx
  - apps/desktop/src/components/StreamingMessage.tsx
autonomous: true
requirements:
  - STRM-04
  - STRM-07

must_haves:
  truths:
    - "Desktop displays reasoning blocks as collapsible sections during streaming and in completed messages"
    - "Desktop displays source attributions as footnote-style links in completed messages"
    - "Reasoning content accumulates during streaming without flicker"
    - "New protocol message types are handled gracefully (no unhandled type errors)"
  artifacts:
    - path: "apps/desktop/src/components/ReasoningBlock.tsx"
      provides: "Collapsible reasoning block UI component"
      contains: "ReasoningBlock"
    - path: "apps/desktop/src/lib/gateway-client.ts"
      provides: "ChatStreamReasoning and ChatStreamSource server message types"
      contains: "chat.stream.reasoning"
    - path: "apps/desktop/src/hooks/useChat.ts"
      provides: "Reasoning and source accumulation in chat state"
      contains: "streamingReasoning"
    - path: "apps/desktop/src/components/StreamingMessage.tsx"
      provides: "Inline reasoning block during streaming"
      contains: "ReasoningBlock"
    - path: "apps/desktop/src/components/MessageCard.tsx"
      provides: "Reasoning block in completed assistant messages"
      contains: "ReasoningBlock"
  key_links:
    - from: "apps/desktop/src/hooks/useChat.ts"
      to: "apps/desktop/src/lib/gateway-client.ts"
      via: "ServerMessage type union for new message types"
      pattern: "chat\\.stream\\.reasoning"
    - from: "apps/desktop/src/components/StreamingMessage.tsx"
      to: "apps/desktop/src/components/ReasoningBlock.tsx"
      via: "import and render ReasoningBlock"
      pattern: "ReasoningBlock"
    - from: "apps/desktop/src/components/MessageCard.tsx"
      to: "apps/desktop/src/components/ReasoningBlock.tsx"
      via: "import and render ReasoningBlock for completed messages"
      pattern: "ReasoningBlock"
---

<objective>
Add reasoning block display and source attribution rendering to the desktop chat interface, handling the new structured streaming message types from the gateway.

Purpose: Users see AI reasoning as a collapsible block (giving transparency into model thinking) and source citations as clickable links, making the desktop chat a premium structured-content experience.

Output: ReasoningBlock component, updated gateway-client types, updated useChat hook, updated message rendering components.
</objective>

<execution_context>
@/Users/drew-mini/.claude/get-shit-done/workflows/execute-plan.md
@/Users/drew-mini/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-structured-streaming-and-chat-formatting/32-RESEARCH.md
@.planning/phases/32-structured-streaming-and-chat-formatting/32-01-SUMMARY.md
@apps/desktop/src/lib/gateway-client.ts
@apps/desktop/src/hooks/useChat.ts
@apps/desktop/src/components/StreamingMessage.tsx
@apps/desktop/src/components/MessageCard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ReasoningBlock component and extend gateway-client types</name>
  <files>
    apps/desktop/src/components/ReasoningBlock.tsx
    apps/desktop/src/lib/gateway-client.ts
  </files>
  <action>
**Create `apps/desktop/src/components/ReasoningBlock.tsx`:**

Build a collapsible reasoning block component using shadcn/ui patterns:

```typescript
import { useState } from "react";
import { ChevronDown, ChevronRight, Brain } from "lucide-react";

interface ReasoningBlockProps {
  content: string;
  isStreaming?: boolean;
  defaultExpanded?: boolean;
}

export function ReasoningBlock({ content, isStreaming = false, defaultExpanded = false }: ReasoningBlockProps) {
  const [expanded, setExpanded] = useState(defaultExpanded);

  return (
    <div className="my-1 rounded border border-muted bg-muted/20">
      <button
        type="button"
        onClick={() => setExpanded((p) => !p)}
        className="flex w-full items-center gap-1.5 px-3 py-1.5 text-xs text-muted-foreground hover:bg-muted/30 transition-colors"
      >
        <Brain className="size-3" />
        <span>Reasoning</span>
        {isStreaming && (
          <span className="relative flex size-1.5 ml-1">
            <span className="absolute inline-flex size-full animate-ping rounded-full bg-primary opacity-75" />
            <span className="relative inline-flex size-1.5 rounded-full bg-primary" />
          </span>
        )}
        {expanded ? <ChevronDown className="ml-auto size-3" /> : <ChevronRight className="ml-auto size-3" />}
      </button>
      {expanded && (
        <div className="border-t border-muted px-3 py-2">
          <p className="whitespace-pre-wrap text-xs italic text-muted-foreground">
            {content}
          </p>
        </div>
      )}
    </div>
  );
}
```

Key details:
- `lucide-react` icons (Brain, ChevronDown, ChevronRight) are already available via shadcn/ui
- Collapsed by default (`defaultExpanded = false`)
- Streaming indicator (pulsing dot) when `isStreaming = true`
- Subtle background and border matching the muted theme
- Hover state on the toggle button

**In `apps/desktop/src/lib/gateway-client.ts`:**

1. Add `ChatStreamReasoning` interface to the Server Message Types section:
```typescript
export interface ChatStreamReasoning {
  type: 'chat.stream.reasoning';
  requestId: string;
  delta: string;
}
```

2. Add `ChatStreamSource` interface:
```typescript
export interface ChatStreamSource {
  type: 'chat.stream.source';
  requestId: string;
  source: { url: string; title?: string };
}
```

3. Add optional `contentType` to existing `ChatStreamDelta`:
```typescript
export interface ChatStreamDelta {
  type: 'chat.stream.delta';
  requestId: string;
  delta: string;
  contentType?: 'text' | 'code';
}
```

4. Add `ChatStreamReasoning` and `ChatStreamSource` to the `ServerMessage` union type.

5. Add a `reasoning` variant to the `ChatMessage` type union:
```typescript
| {
    type: 'reasoning';
    id: string;
    content: string;
    timestamp: number;
  }
```

6. Add a `sources` variant to the `ChatMessage` type union:
```typescript
| {
    type: 'sources';
    id: string;
    sources: Array<{ url: string; title?: string }>;
    timestamp: number;
  }
```
  </action>
  <verify>
Run `npx tsc --noEmit` from `apps/desktop` to confirm no TypeScript errors. Verify ReasoningBlock.tsx exports the component. Verify gateway-client.ts ServerMessage union includes the new types.
  </verify>
  <done>
ReasoningBlock.tsx created with collapsible UI, streaming indicator, and Brain icon. gateway-client.ts has ChatStreamReasoning, ChatStreamSource in ServerMessage union, and reasoning/sources ChatMessage variants. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update useChat hook and message components to render reasoning and sources</name>
  <files>
    apps/desktop/src/hooks/useChat.ts
    apps/desktop/src/components/StreamingMessage.tsx
    apps/desktop/src/components/MessageCard.tsx
  </files>
  <action>
**In `apps/desktop/src/hooks/useChat.ts`:**

1. Add `streamingReasoning` state and ref (same pattern as `streamingText`):
```typescript
const [streamingReasoning, setStreamingReasoning] = useState('');
const streamingReasoningRef = useRef('');
```

2. Add `pendingSources` ref to accumulate sources during a request:
```typescript
const pendingSourcesRef = useRef<Array<{ url: string; title?: string }>>([]);
```

3. In the `handleMessage` callback, add cases for new message types:

For `chat.stream.reasoning`:
```typescript
case 'chat.stream.reasoning': {
  streamingReasoningRef.current += msg.delta;
  setStreamingReasoning(streamingReasoningRef.current);
  break;
}
```

For `chat.stream.source`:
```typescript
case 'chat.stream.source': {
  pendingSourcesRef.current.push(msg.source);
  break;
}
```

4. In the `chat.stream.start` handler, also clear reasoning state:
```typescript
setStreamingReasoning('');
streamingReasoningRef.current = '';
pendingSourcesRef.current = [];
```

5. In the `chat.stream.end` handler, after creating the text message, also create a reasoning message (if reasoning was accumulated) and a sources message (if sources were accumulated):
```typescript
// After the completed text message is added...
const completedReasoning = streamingReasoningRef.current;
if (completedReasoning) {
  setMessages((prev) => [
    ...prev,
    {
      type: 'reasoning',
      id: crypto.randomUUID(),
      content: completedReasoning,
      timestamp: Date.now(),
    },
  ]);
}
const collectedSources = pendingSourcesRef.current;
if (collectedSources.length > 0) {
  setMessages((prev) => [
    ...prev,
    {
      type: 'sources',
      id: crypto.randomUUID(),
      sources: [...collectedSources],
      timestamp: Date.now(),
    },
  ]);
}
// Clear reasoning state
setStreamingReasoning('');
streamingReasoningRef.current = '';
pendingSourcesRef.current = [];
```

IMPORTANT: The reasoning message should be added BEFORE the text message in the messages array so it appears above the response content. Restructure so reasoning message is pushed first, then the text message.

6. Add `streamingReasoning` to the return object and the `UseChatReturn` interface:
```typescript
interface UseChatReturn {
  // ... existing fields ...
  streamingReasoning: string;
}
```

7. In `clearMessages`, also clear reasoning state:
```typescript
setStreamingReasoning('');
streamingReasoningRef.current = '';
pendingSourcesRef.current = [];
```

**In `apps/desktop/src/components/StreamingMessage.tsx`:**

1. Import `ReasoningBlock` from `@/components/ReasoningBlock`.

2. Add `reasoning` prop:
```typescript
interface StreamingMessageProps {
  text: string;
  reasoning?: string;
  isStreaming: boolean;
  model?: string | null;
}
```

3. Render `ReasoningBlock` above the Streamdown content when reasoning is non-empty:
```typescript
{reasoning && (
  <ReasoningBlock content={reasoning} isStreaming={isStreaming} />
)}
```

**In `apps/desktop/src/components/MessageCard.tsx`:**

1. Import `ReasoningBlock` from `@/components/ReasoningBlock`.

2. Handle the new `reasoning` message type -- render it as a standalone ReasoningBlock:
```typescript
if (message.type === 'reasoning') {
  return <ReasoningBlock content={message.content} />;
}
```

3. Handle the new `sources` message type -- render as a list of footnote-style links:
```typescript
if (message.type === 'sources') {
  return (
    <div className="mr-auto max-w-[80%] px-4 py-1">
      <p className="text-[10px] font-medium text-muted-foreground mb-1">Sources</p>
      <ul className="space-y-0.5">
        {message.sources.map((s, i) => (
          <li key={i} className="text-[11px] text-muted-foreground">
            <a
              href={s.url}
              target="_blank"
              rel="noopener noreferrer"
              className="underline hover:text-foreground transition-colors"
            >
              {s.title || s.url}
            </a>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

4. Update the caller in the ChatView (where StreamingMessage is rendered) to pass the `streamingReasoning` prop. Check the parent component that uses `useChat` and `StreamingMessage` -- pass `reasoning={streamingReasoning}` to `StreamingMessage`.
  </action>
  <verify>
Run `npx tsc --noEmit` from `apps/desktop` to confirm no TypeScript errors. Verify StreamingMessage accepts and renders reasoning prop. Verify MessageCard handles reasoning and sources message types.
  </verify>
  <done>
useChat accumulates reasoning text and sources during streaming, promotes them to messages on stream end. StreamingMessage renders ReasoningBlock above response text during streaming. MessageCard renders reasoning blocks (collapsible) and sources (footnote links) in completed message history. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes from apps/desktop with zero errors
2. ReasoningBlock.tsx renders a collapsible block with Brain icon, collapsed by default
3. gateway-client.ts ServerMessage union includes ChatStreamReasoning and ChatStreamSource
4. useChat handles `chat.stream.reasoning` and `chat.stream.source` message types
5. StreamingMessage shows ReasoningBlock above streaming content when reasoning is present
6. MessageCard renders standalone reasoning blocks and source links for completed messages
</verification>

<success_criteria>
- Desktop chat displays reasoning as a collapsible block (collapsed by default, expandable to full text)
- Reasoning streams in real-time with a pulsing indicator
- Source attributions render as clickable footnote-style links
- No unhandled message type warnings in console
- All existing chat functionality (text streaming, tool calls, tool approval) unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/32-structured-streaming-and-chat-formatting/32-02-SUMMARY.md`
</output>
