---
phase: 34-cli-chat-ux-overhaul
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/cli/src/components/FullScreenWrapper.tsx
  - packages/cli/src/components/ConversationScroll.tsx
  - packages/cli/src/components/Divider.tsx
  - packages/cli/src/components/Chat.tsx
  - packages/cli/src/components/InputBar.tsx
  - packages/cli/src/components/StatusBar.tsx
  - packages/cli/src/components/WelcomeScreen.tsx
  - packages/cli/src/components/MessageList.tsx
  - packages/cli/src/commands/chat.ts
autonomous: true
requirements: [CLIX-01, CLIX-02, CLIX-03, CLIX-04]

must_haves:
  truths:
    - "CLI chat opens in fullscreen mode (alternate screen buffer) filling the entire terminal"
    - "Input zone is fixed at the bottom with a visible border and > prompt prefix"
    - "User can move cursor left/right within input text and insert/delete at cursor position"
    - "Input expands as user types multiline content up to 6 lines max"
    - "Status line appears below input showing model, connection dot, token count, cost"
    - "Conversation history scrolls in the area above the input zone"
    - "Terminal resize updates the layout dimensions dynamically"
    - "Top status bar is removed -- all status info is in the bottom line"
  artifacts:
    - path: "packages/cli/src/components/FullScreenWrapper.tsx"
      provides: "Alternate screen buffer with resize handling"
      contains: "1049h"
    - path: "packages/cli/src/components/ConversationScroll.tsx"
      provides: "Windowed message rendering replacing Static"
      contains: "overflow"
    - path: "packages/cli/src/components/Divider.tsx"
      provides: "Horizontal rule separator"
      contains: "repeat"
    - path: "packages/cli/src/components/InputBar.tsx"
      provides: "Cursor-aware multiline input with border"
      contains: "cursorPos"
    - path: "packages/cli/src/components/StatusBar.tsx"
      provides: "Bottom-pinned single-line status"
      contains: "permission"
  key_links:
    - from: "packages/cli/src/components/Chat.tsx"
      to: "packages/cli/src/components/FullScreenWrapper.tsx"
      via: "wraps entire layout"
      pattern: "FullScreenWrapper"
    - from: "packages/cli/src/components/Chat.tsx"
      to: "packages/cli/src/components/ConversationScroll.tsx"
      via: "replaces Static/MessageList"
      pattern: "ConversationScroll"
    - from: "packages/cli/src/components/InputBar.tsx"
      to: "packages/cli/src/hooks/useInputHistory.js"
      via: "history navigation on Up/Down when empty"
      pattern: "useInputHistory"
---

<objective>
Transform the CLI chat from a simple vertical flex layout into a fullscreen terminal application with Claude Code-style UX: alternate screen buffer, windowed conversation scroll area, fixed bordered input zone with cursor-aware editing at the bottom, status line pinned below input, and horizontal divider separating conversation from input.

Purpose: This is the foundational layout restructure that all Phase 34 rendering changes depend on. Without fullscreen mode and the new layout zones, inline tool calls, inline approvals, and diffs cannot be properly positioned.

Output: Fully functional fullscreen CLI chat with new layout structure, cursor-aware input, and bottom status bar. All existing functionality (messaging, streaming, approvals) preserved in new layout.
</objective>

<execution_context>
@/Users/drew-mini/.claude/get-shit-done/workflows/execute-plan.md
@/Users/drew-mini/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-cli-chat-ux-overhaul/34-CONTEXT.md
@.planning/phases/34-cli-chat-ux-overhaul/34-RESEARCH.md

Key existing files to read before implementing:
@packages/cli/src/components/Chat.tsx
@packages/cli/src/components/InputBar.tsx
@packages/cli/src/components/StatusBar.tsx
@packages/cli/src/components/MessageList.tsx
@packages/cli/src/components/MessageBubble.tsx
@packages/cli/src/components/StreamingResponse.tsx
@packages/cli/src/components/WelcomeScreen.tsx
@packages/cli/src/components/ToolApprovalPrompt.tsx
@packages/cli/src/components/SkillApprovalPrompt.tsx
@packages/cli/src/components/PreflightChecklist.tsx
@packages/cli/src/components/TodoPanel.tsx
@packages/cli/src/commands/chat.ts
@packages/cli/src/hooks/useChat.ts
@packages/cli/src/hooks/useInputHistory.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fullscreen layout components and restructure Chat.tsx</name>
  <files>
    packages/cli/src/components/FullScreenWrapper.tsx
    packages/cli/src/components/ConversationScroll.tsx
    packages/cli/src/components/Divider.tsx
    packages/cli/src/components/Chat.tsx
    packages/cli/src/components/WelcomeScreen.tsx
    packages/cli/src/components/MessageList.tsx
    packages/cli/src/commands/chat.ts
  </files>
  <action>
    **Create FullScreenWrapper.tsx** -- Manual alternate screen buffer management (do NOT use fullscreen-ink dependency, use manual escape codes which are more reliable with Ink 6.7.0):
    - On mount: write `\x1b[?1049h` to enter alternate screen buffer, `\x1b[?25l` to hide cursor (Ink manages its own)
    - On unmount: write `\x1b[?25h` to show cursor, `\x1b[?1049l` to leave alternate screen
    - Track terminal dimensions via `useStdout()` -- read `stdout.rows` and `stdout.columns`
    - Listen to stdout `resize` event to update dimensions state
    - Provide dimensions to children via props or context (props preferred for simplicity)
    - Render children inside `<Box flexDirection="column" width={width} height={height}>`
    - Fallback: `width = stdout?.columns ?? 80`, `height = stdout?.rows ?? 24`

    **Create ConversationScroll.tsx** -- Windowed message rendering replacing `<Static>`:
    - Accept `messages: ChatMessage[]`, `availableHeight: number`, and optional streaming/approval children as props
    - Use a simple "render last N messages" approach (research-recommended): calculate how many messages fit and render only the tail end
    - Set `overflow="hidden"` on the containing Box to prevent overflow
    - Use `flexGrow={1}` so it fills all space between top of screen and the divider
    - Auto-scroll behavior: always show latest content (simple, matches streaming chat UX)
    - Render WelcomeScreen inside this area when messages are empty and not streaming
    - Render streaming content (StreamingResponse), TodoPanel, and active tool calls INSIDE this scroll area (they scroll with conversation)
    - Render inline approval dialogs inside this area when pending (they appear at the bottom of the scroll)
    - NOTE: Do NOT attempt to measure exact message heights. Use a generous estimate (each message = 3-5 lines as heuristic) and let `overflow="hidden"` handle clipping. This can be refined later.

    **Create Divider.tsx** -- Thin horizontal rule separator:
    - Use `useStdout()` to get terminal width
    - Render a single line of `"---"` repeated to fill width using `Text dimColor`
    - Character: use the thin box-drawing character `\u2500` ("---") for a clean look

    **Restructure Chat.tsx** -- New layout architecture:
    ```
    <FullScreenWrapper>
      <ConversationScroll flexGrow={1}>
        {/* WelcomeScreen when empty */}
        {/* MessageBubble for each message (windowed) */}
        {/* StreamingResponse when streaming */}
        {/* TodoPanel when todos active */}
        {/* ToolPanel for live tool calls (rendered inline) */}
        {/* Approval dialogs when pending (rendered inline) */}
      </ConversationScroll>
      <Divider />
      <InputBar />  {/* fixed height at bottom */}
      <StatusBar />  {/* single line at very bottom */}
    </FullScreenWrapper>
    ```
    - Remove `<Static>` usage entirely (no more MessageList with Static)
    - Remove padding={1} from the outer Box (fullscreen uses all terminal space)
    - Pass `availableHeight` to ConversationScroll calculated as: `screenHeight - inputHeight - statusHeight(1) - dividerHeight(1)`
    - Keep all existing approval/submit/preflight handler logic intact
    - The approval prompts (ToolApprovalPrompt, SkillApprovalPrompt, PreflightChecklist) should now render INSIDE ConversationScroll, not as replacements for InputBar
    - InputBar should ALWAYS be visible (disabled during approvals via `isActive` prop)
    - Pass `pendingApproval` or `pendingPreflight` to InputBar as a signal to disable input

    **Update WelcomeScreen.tsx** -- Remove the padding (parent ConversationScroll handles spacing). Keep content the same.

    **MessageList.tsx** -- This file can be deleted or emptied. Its `<Static>` rendering is replaced by ConversationScroll's direct rendering of messages. If deleting feels risky, just export a no-op or re-export ConversationScroll.

    **Update chat.ts** -- No changes needed to the render() call itself, but verify it still works with the fullscreen approach. The `render()` from Ink should be compatible with alternate screen buffer managed inside the component.
  </action>
  <verify>
    1. `cd /Users/drew-mini/Documents/GitHub/tek && npx turbo build --filter=@tek/cli` -- builds without TypeScript errors
    2. Visually inspect that FullScreenWrapper.tsx contains alternate screen buffer escape codes
    3. Verify Chat.tsx no longer imports `Static` from ink or `MessageList`
    4. Verify ConversationScroll.tsx uses `overflow="hidden"` and `flexGrow={1}`
  </verify>
  <done>
    Chat component uses FullScreenWrapper for alternate screen buffer, ConversationScroll for windowed messages (no Static), Divider separates conversation from input zone, and the layout structure matches the target architecture diagram from RESEARCH.md.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite InputBar with cursor editing and StatusBar for bottom placement</name>
  <files>
    packages/cli/src/components/InputBar.tsx
    packages/cli/src/components/StatusBar.tsx
    packages/cli/src/hooks/useInputHistory.ts
  </files>
  <action>
    **Rewrite InputBar.tsx** -- Complete cursor-aware multiline input:

    Props: `{ onSubmit, isActive, screenWidth }` (isActive replaces isStreaming -- false during streaming OR approval)

    State:
    - `text: string` -- full input text
    - `cursorPos: number` -- character position within `text` (0-indexed)

    Key handling via `useInput` with `{ isActive }`:
    - **Regular characters** (no ctrl/meta): Insert at cursor position -- `text.slice(0, cursorPos) + input + text.slice(cursorPos)`, advance cursor by input.length
    - **Enter** (no shift): Submit if text is non-empty, push to history, reset text and cursor to 0
    - **Shift+Enter**: Insert `\n` at cursor position, advance cursor by 1
    - **Left arrow**: Move cursor left by 1 (min 0)
    - **Right arrow**: Move cursor right by 1 (max text.length)
    - **Backspace**: Delete character before cursor (if cursor > 0), move cursor back by 1
    - **Delete**: Delete character at cursor position (if cursor < text.length)
    - **Home** (Ctrl+A): Move cursor to 0
    - **End** (Ctrl+E): Move cursor to text.length
    - **Up arrow** (when text is empty): history.back(), set text and cursor to end
    - **Down arrow** (when text is empty): history.forward(), set text and cursor to end
    - **Escape**: Clear input (set text to "", cursor to 0) -- "esc to undo" as mentioned in CONTEXT.md

    Visual rendering:
    - Outer Box with `borderStyle="round"` and `borderColor="cyan"` (Tek's color, distinct from Claude Code's yellow)
    - First line starts with `>` prompt prefix in bold cyan
    - Text rendered with cursor visualization: text before cursor as normal Text, cursor position shown with `<Text inverse> </Text>` (inverse block), text after cursor as normal Text
    - Split text by `\n` for multiline display. Each continuation line indented by 2 spaces (matching prompt width)
    - **Max 6 visible lines**: if text has more than 6 lines, only show the last 6 (internal scroll). Show a "(N more lines above)" indicator.
    - **Placeholder**: When text is empty and isActive, show dimmed placeholder: "Ask anything... (! for bash, / for commands)"
    - **Disabled state**: When !isActive, show dimmed "waiting..." text instead of input

    Hint line below the bordered box (outside the border, inside InputBar component):
    - `<Text dimColor>  Enter to send . Shift+Enter for newline . Esc to clear . arrows to move</Text>`
    - This is a single line, always visible

    IMPORTANT: Use `string-width` (transitive dep of Ink, import from `string-width`) for cursor positioning math if handling CJK/emoji. For MVP, `string.length` is acceptable since the primary concern is ASCII editing. Add a TODO comment noting string-width improvement for non-ASCII.

    **Rewrite StatusBar.tsx** -- Bottom-pinned single-line status:

    Props: `{ connected, model, usage, permissionMode? }` (remove sessionId prop -- not displayed in new design)

    Render a single `<Box justifyContent="space-between">` line:
    - Left zone: connection dot (green/red `Text`) + shortened model name (cyan)
    - Center zone: (leave empty or skip -- justifyContent handles spacing)
    - Right zone: token count + cost (dimmed) + permission mode badge

    Model shortening: Keep existing logic `replace("claude-", "").replace(/-\d{8}$/, "")`

    Permission mode display: Show "Full Ctrl" or "Limited" based on permissionMode prop. If prop is undefined, omit. Use dimmed text with a subtle indicator. Per CONTEXT.md, show keyboard shortcut to cycle: "shift+tab" but since this is display-only for now, just show the current mode.

    The StatusBar should have NO border, NO padding -- it's a single compact line at the very bottom.

    **Update useInputHistory.ts** -- Minor update: when navigating history (back/forward), the cursor should be set to the end of the recalled text. This is handled in InputBar by setting `setCursorPos(text.length)` after `setText(historyEntry)`, so no changes needed to the hook itself. Verify the hook API is compatible.
  </action>
  <verify>
    1. `cd /Users/drew-mini/Documents/GitHub/tek && npx turbo build --filter=@tek/cli` -- builds without TypeScript errors
    2. Verify InputBar.tsx contains `cursorPos` state and `useInput` handler with left/right/home/end/backspace/delete cases
    3. Verify InputBar.tsx renders with `borderStyle="round"` and has the hint line
    4. Verify StatusBar.tsx is a single-line component with no border
    5. Verify Chat.tsx passes `isActive` (not `isStreaming`) to InputBar
  </verify>
  <done>
    InputBar has full cursor-aware editing with left/right navigation, Home/End support, bordered box, expandable up to 6 lines, placeholder text, and hint line. StatusBar is a compact single-line component positioned below the input. The top status bar placement is removed from Chat.tsx layout.
  </done>
</task>

</tasks>

<verification>
1. `npx turbo build --filter=@tek/cli` passes with zero errors
2. Chat.tsx imports FullScreenWrapper, ConversationScroll, Divider (not Static, not MessageList)
3. InputBar.tsx has cursor state management (cursorPos) and bordered rendering
4. StatusBar.tsx is a borderless single-line component
5. No `<Static>` usage anywhere in the chat components
6. FullScreenWrapper.tsx manages alternate screen buffer lifecycle
</verification>

<success_criteria>
- CLI chat launches in fullscreen mode with alternate screen buffer
- Conversation messages render in a windowed scroll area above the input
- Input zone is bordered, fixed at bottom, with cursor-aware editing
- Status line appears below input as a single compact line
- Horizontal divider separates conversation from input
- All existing functionality (messaging, streaming, tool calls, approvals) still works
- Terminal resize updates layout dimensions
</success_criteria>

<output>
After completion, create `.planning/phases/34-cli-chat-ux-overhaul/34-01-SUMMARY.md`
</output>
